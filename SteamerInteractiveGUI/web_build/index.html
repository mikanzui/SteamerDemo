<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Steamer Interactive GUI (v3.6)</title>
    <style>
        body { margin: 0; padding: 0; background-color: #1e1e1e; font-family: 'Segoe UI', sans-serif; color: #eeeeee; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        #controls-bar { background-color: #2b2b2b; padding: 5px 20px; display: flex; justify-content: center; align-items: center; border-bottom: 1px solid #333; flex-shrink: 0; }
        .control-group { display: flex; flex-direction: column; align-items: flex-start; margin: 0 15px; }
        .group-label { font-size: 10px; font-weight: bold; color: #888888; margin-bottom: 8px; text-transform: uppercase; }
        .row-frame { display: flex; align-items: center; }
        button { background-color: #3a3a3a; color: #e0e0e0; border: none; padding: 8px 15px; font-family: 'Segoe UI', sans-serif; font-size: 12px; font-weight: bold; cursor: pointer; margin-right: 5px; min-width: 100px; border-radius: 0px; outline: none; transition: background-color 0.2s; }
        button:hover { background-color: #454545; }
        button:active { background-color: #505050; }
        .separator { width: 1px; background-color: #444444; height: 30px; margin: 0 30px; }
        .led-indicator { width: 10px; height: 10px; border-radius: 50%; background-color: #3a3a3a; border: 1px solid #505050; margin-left: 5px; }
        .text-status { font-size: 11px; font-weight: bold; color: #555555; margin-left: 5px; width: 70px; text-align: center; }
        #main-content { display: flex; flex: 1; overflow: hidden; flex-direction: row; background-color: #000000; }
        #image-area { flex: 1; background-color: #000000; display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative; overflow: hidden; }
        #wrapper { position: relative; } 
        #bg-image { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: fill; pointer-events: none; z-index: 1; }
        #bg-image-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: fill; pointer-events: none; z-index: 2; opacity: 0; transition: opacity 0.1s linear; }
        #interaction-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; touch-action: none; cursor: pointer; z-index: 3; }
        #guide-label { margin-top: 10px; color: #666666; font-size: 13px; font-weight: bold; text-align: center; position: absolute; bottom: 10px; width: 100%; pointer-events: none; z-index: 4; }
        #sidebar { width: 300px; background-color: #1a1a1a; display: flex; flex-direction: column; border-left: none; flex-shrink: 0; overflow-y: auto; }
        .sidebar-header { color: white; font-size: 16px; font-weight: bold; padding: 20px 10px 0 10px; background-color: #1a1a1a; }
        .sidebar-sub { color: #666666; font-size: 12px; padding: 5px 10px 10px 10px; }
        #flow-canvas { width: 280px; height: 450px; margin: 0 10px; }
        @media (max-width: 768px) { #main-content { flex-direction: column; } #sidebar { width: 100%; height: 300px; border-top: 1px solid #333; } #flow-canvas { width: 100%; } #controls-bar { flex-wrap: wrap; } .separator { display: none; } .control-group { margin-bottom: 10px; } }
        #login-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #1e1e1e; z-index: 9999; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        #login-box { background-color: #252526; padding: 30px; border: 1px solid #333; border-radius: 5px; text-align: center; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        #login-input { padding: 8px; margin: 10px 0; background-color: #333; border: 1px solid #555; color: white; border-radius: 3px; outline: none; }
        #login-btn { background-color: #007acc; color: white; border: none; padding: 8px 15px; cursor: pointer; border-radius: 3px; font-weight: bold; }
    </style>
</head>
<body>
    <div id="login-overlay"><div id="login-box"><h2 style="margin-top: 0;">Restricted Access</h2><p style="color: #ccc; font-size: 14px;">Enter password
    </p><input type="password" id="login-input" placeholder="Password"><br><button id="login-btn" onclick="checkPassword()">Enter</button><p id="login-error" style="color: #ff6b6b; font-size: 12px; margin-top: 10px; display: none;">Incorrect password</p></div></div>

    <div id="controls-bar">
        <div class="control-group"><span class="group-label">MAIN POWER</span><div class="row-frame"><button onclick="triggerAction('Power')">POWER</button><div id="led-power" class="led-indicator"></div></div></div>
        <div class="separator"></div>
        <div class="control-group"><span class="group-label">INTENSITY</span><div class="row-frame"><button onclick="triggerAction('Boost')">BOOST</button><div id="led-boost" class="led-indicator"></div></div></div>
        <div class="separator"></div>
        <div class="control-group"><span class="group-label">OPERATION</span><div class="row-frame"><button onmousedown="startHold()" onmouseup="stopHold()" ontouchstart="startHold(event)" ontouchend="stopHold(event)" style="width: 140px;">HOLD TO STEAM</button><span id="text-status" class="text-status">READY</span></div></div>
        <div class="separator"></div>
        <div class="control-group"><span class="group-label">VIEW MODE</span><div class="row-frame"><button id="btn-view" onclick="toggleViewMode()">SWITCH TO<br>RENDERS</button></div></div>
    </div>

    <div id="main-content">
        <div id="image-area">
            <div id="wrapper">
                <img id="bg-image" draggable="false">
                <img id="bg-image-overlay" draggable="false">
                <canvas id="interaction-canvas"></canvas>
            </div>
            <div id="guide-label">INTERACTIVE MODE: Click the buttons on the product image (Main or Side view) to operate.</div>
        </div>
        <div id="sidebar">
            <div class="sidebar-header">State Overview</div><div class="sidebar-sub">Logic Decision Tree:</div><canvas id="flow-canvas"></canvas>
        </div>
    </div>

    <script>
        function checkPassword() { if (document.getElementById('login-input').value === 'steamer2024') { document.getElementById('login-overlay').style.display = 'none'; startLoop(); } else { document.getElementById('login-error').style.display = 'block'; document.getElementById('login-input').value = ''; } }
        document.getElementById('login-input').addEventListener('keypress', e => { if (e.key === 'Enter') checkPassword(); });

        const originalWidth = 4000;
        const originalHeight = 2110;
        const linePoints = { 
            "Power": { x: 597, y: 669 }, 
            "Boost": { x: 597, y: 800 }, 
            "Hold": { x: 1776, y: 877, r: 60 }, 
            "Steam": { x: 3477, y: 325 }, 
            "Power_Side": { x: 2634, y: 674 }, 
            "Boost_Side": { x: 2637, y: 797 },
            "Hold_Side": { x: 2914, y: 872, r: 60 }
        };
        const renderPoints = {
            "Power": { x: 898, y: 833 },
            "Boost": { x: 898, y: 944 },
            "Hold": { x: 1931, y: 1008, r: 150 }, // Increased Radius
            "Power_Side": { x: 2688, y: 809 },
            "Boost_Side": { x: 2688, y: 925 },
            "Hold_Side": { x: 2883, y: 987, r: 150 } // Increased Radius
        };
        const lineRadius = 50; const renderRadius = 45; // Reverted base radius (Steam has explicit override)

        const images = {};
        const imageFiles = { 'line': 'steamer.png', 'alloff': 'Renders/alloff.jpg', 'on': 'Renders/on.jpg', 'onwithsteam': 'Renders/onwithsteam.jpg', 'onwithboost': 'Renders/onwithboost.jpg', 'onboostwithsteam': 'Renders/onboostwithsteam.jpg' };
        for (const [key, src] of Object.entries(imageFiles)) { images[key] = new Image(); images[key].src = src; }

        let state = { powerOn: false, mode: 1, targetMode: 1, holdActive: false, isHeating: false, heatingStartTime: 0, heatingProgress: 0.0, pulseIntensity: 0.0, viewMode: 'line' };

        function triggerAction(name) {
            if (name.includes('Power')) { 
                if (!state.powerOn) { 
                    // Turn ON -> Start Heating for Normal Mode (1)
                    state.powerOn = true; 
                    startHeating(1); 
                } else { 
                    // Turn OFF
                    state.powerOn = false; 
                    state.mode = 1; 
                    state.holdActive = false; 
                    cancelHeating(); 
                } 
            }
            else if (name.includes('Boost')) { 
                if (state.powerOn) { 
                    if (state.mode === 1) startHeating(2); // Start Heating for Boost Mode (2)
                    else state.mode = 1; // Return to Normal immediately
                } 
            }
            updateControls();
        }
        function startHeating(target) { 
            state.isHeating = true; 
            state.targetMode = target;
            state.heatingStartTime = performance.now() / 1000; 
            state.heatingProgress = 0.0; 
        }
        function cancelHeating() { state.isHeating = false; }
        function finishHeating() { 
            state.isHeating = false; 
            state.mode = state.targetMode; 
        }
        function startHold(e) { if (e) e.preventDefault(); if (state.powerOn) { state.holdActive = true; updateControls(); } }
        function stopHold(e) { state.holdActive = false; updateControls(); }
        function toggleViewMode() { state.viewMode = (state.viewMode === 'line') ? 'render' : 'line'; document.getElementById('btn-view').innerHTML = state.viewMode === 'line' ? "SWITCH TO<br>RENDERS" : "SWITCH TO<br>LINES"; }

        function startLoop() { requestAnimationFrame(loop); }
        function loop(timestamp) {
            const now = timestamp / 1000;
            if (state.isHeating) {
                if (!state.powerOn || state.holdActive) cancelHeating();
                else {
                    const elapsed = now - state.heatingStartTime;
                    state.heatingProgress = Math.min(1.0, elapsed / 8.0); // 8s Duration
                    if (state.heatingProgress >= 1.0) finishHeating();
                    const pulsePhase = elapsed * (Math.PI * 2);
                    state.pulseIntensity = 0.2 + (((Math.sin(pulsePhase) + 1) / 2) * 0.8);
                }
            } else state.pulseIntensity = 0.0;
            drawMain(); drawFlowchart(); requestAnimationFrame(loop);
        }

        const mainCanvas = document.getElementById('interaction-canvas');
        const mainCtx = mainCanvas.getContext('2d');
        const bgImgElement = document.getElementById('bg-image');
        const bgImgOverlay = document.getElementById('bg-image-overlay');
        const wrapper = document.getElementById('wrapper');

        function resizeMainCanvas() {
            const container = document.getElementById('image-area');
            const dpr = window.devicePixelRatio || 1;
            const cw = container.clientWidth; const ch = container.clientHeight;
            const ratio = originalWidth / originalHeight;
            let newW = cw; let newH = cw / ratio;
            if (newH > ch) { newH = ch; newW = ch * ratio; }
            
            // Resize wrapper to hold both
            wrapper.style.width = newW + 'px';
            wrapper.style.height = newH + 'px';

            mainCanvas.width = newW * dpr; mainCanvas.height = newH * dpr;
            mainCtx.imageSmoothingEnabled = true; mainCtx.imageSmoothingQuality = 'high';
            // Note: bgImgElement sizes automatically to wrapper 100%
        }
        window.addEventListener('resize', resizeMainCanvas); resizeMainCanvas();

        let currentBgSrc = "";
        let currentOverlaySrc = "";

        function drawMain() {
            mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
            let bgImage = images.line;
            let overlayImage = null; // Default no overlay
            let overlayOpacity = 0.0;
            
            // Determine Render Images
            if (state.viewMode === 'render') {
                if (state.powerOn) {
                    if (state.isHeating) {
                        // Heating: Pulse Effect
                        // Make sine wave 0 -> 1 for opacity
                        const normalizedPulse = (Math.sin(performance.now() / 1000 * Math.PI * 2) + 1) / 2; // Simple 0-1 Sine
                        
                        // NOTE: state.pulseIntensity in loop was slightly different formula, using simple one here for smooth visual
                        
                        if (state.targetMode === 2) {
                             // Boost Heating: Base=ON, Overlay=ON+BOOST
                             bgImage = images.on;
                             overlayImage = images.onwithboost;
                             overlayOpacity = normalizedPulse; // Fade in orange boost
                        } else {
                             // Power Heating: Base=OFF, Overlay=ON
                             bgImage = images.alloff;
                             overlayImage = images.on;
                             overlayOpacity = normalizedPulse; // Fade in green power
                        }
                    } else {
                        // Steady State
                        if (state.mode === 2) {
                            bgImage = state.holdActive ? images.onboostwithsteam : images.onwithboost;
                        } else {
                            bgImage = state.holdActive ? images.onwithsteam : images.on;
                        }
                    }
                } else {
                    bgImage = images.alloff;
                }
            }

            // Update DOM Images (Base)
            if (bgImage && currentBgSrc !== bgImage.src) {
                bgImgElement.src = bgImage.src;
                currentBgSrc = bgImage.src;
            }

            // Update DOM Images (Overlay)
            if (overlayImage) {
                if (currentOverlaySrc !== overlayImage.src) {
                    bgImgOverlay.src = overlayImage.src;
                    currentOverlaySrc = overlayImage.src;
                }
                bgImgOverlay.style.opacity = overlayOpacity.toFixed(2);
                bgImgOverlay.style.display = 'block';
            } else {
                bgImgOverlay.style.opacity = 0;
                bgImgOverlay.style.display = 'none'; // Performance optimization
            }

            // Tint: Use CSS Filter
            if (state.viewMode === 'line' && bgImage === images.line) {
                bgImgElement.style.filter = 'invert(1)';
            } else {
                bgImgElement.style.filter = 'none';
            }

            const scale = mainCanvas.width / originalWidth;

            if (state.viewMode === 'line' && state.powerOn) {
                // Line View Logic (Unchanged)
                mainCtx.globalCompositeOperation = 'screen';
                
                // Active Logic for Power Glow
                let powerInt = 1.0;
                if (state.isHeating && state.targetMode === 1) powerInt = state.pulseIntensity;
                drawGlow(mainCtx, linePoints.Power.x, linePoints.Power.y, scale, powerInt);
                drawGlow(mainCtx, linePoints.Power_Side.x, linePoints.Power_Side.y, scale, powerInt);
                
                // Active Logic for Boost Glow
                if (state.mode === 2 || (state.isHeating && state.targetMode === 2)) {
                    let boostInt = (state.isHeating && state.targetMode === 2) ? state.pulseIntensity : 1.0;
                    drawGlow(mainCtx, linePoints.Boost.x, linePoints.Boost.y, scale, boostInt);
                    drawGlow(mainCtx, linePoints.Boost_Side.x, linePoints.Boost_Side.y, scale, boostInt);
                }
                if (state.holdActive) {
                     const isBoost = (state.mode === 2);
                     drawSteamCloud(mainCtx, linePoints.Steam.x * scale, linePoints.Steam.y * scale, "white", isBoost, scale);
                }
                mainCtx.globalCompositeOperation = 'source-over';
            }
            if (state.isHeating && !state.holdActive) drawHeatingOverlay(mainCtx, scale);
        }

        function drawGlow(ctx, x, y, scale, intensity) {
            const r = lineRadius * scale * 1.6; const gx = x * scale; const gy = y * scale;
            const grad = ctx.createRadialGradient(gx, gy, 0, gx, gy, r);
            grad.addColorStop(0, `rgba(255, 255, 255, ${intensity})`); grad.addColorStop(1, `rgba(255, 255, 255, 0)`);
            ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(gx, gy, r, 0, Math.PI * 2); ctx.fill();
        }
        
        function drawSteamCloud(ctx, x, y, color, isBoost, scaleBase) { 
            ctx.save();
            // Move up slightly to compensate for rotation
            ctx.translate(x, y - (25 * scaleBase));
            ctx.rotate(-10 * Math.PI / 180); // Rotate -10 degrees (Side output)
            
            const boostScale = isBoost ? 1.4 : 1.0;
            const finalScale = scaleBase * boostScale * 2.0; // DOUBLE SIZE
            // Soft Blur Filter
            ctx.filter = `blur(${8 * finalScale}px)`; 
            // Body (Centered at 0,0 after translate)
            ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
            ctx.beginPath(); ctx.ellipse(0, 0, 60 * finalScale, 30 * finalScale, 0, 0, Math.PI * 2); ctx.fill();
            // Core Line
            const width = (isBoost ? 180 : 120) * finalScale;
            ctx.lineWidth = (isBoost ? 10 : 6) * finalScale; ctx.strokeStyle = "rgba(255, 255, 255, 0.6)"; ctx.lineCap = 'round';
            ctx.beginPath(); ctx.moveTo(-width/2, 0); ctx.lineTo(width/2, 0); ctx.stroke();
            ctx.restore();
        }

        function drawHeatingOverlay(ctx, scale) {
             const cx = ctx.canvas.width / 2; const yTop = 10; const w = 300; const h = 100;
             ctx.fillStyle = "#2b2b2b"; ctx.strokeStyle = "#ffffff"; ctx.lineWidth = 2;
             ctx.fillRect(cx - w/2, yTop, w, h); ctx.strokeRect(cx - w/2, yTop, w, h);
             ctx.fillStyle = "#ffffff"; ctx.font = "bold 16px Segoe UI"; ctx.textAlign = "center";
             const title = state.targetMode === 2 ? "HEATING UP (BOOST)..." : "HEATING UP...";
             ctx.fillText(title, cx, yTop + 35);
             const barW = 250; const barH = 12; const bx = cx - barW/2; const by = yTop + 55;
             ctx.fillStyle = "#444444"; ctx.fillRect(bx, by, barW, barH);
             const fillW = barW * state.heatingProgress; ctx.fillStyle = "#ffffff"; ctx.fillRect(bx, by, fillW, barH);
             ctx.fillStyle = "#aaaaaa"; ctx.font = "12px Segoe UI";
             const percent = Math.floor(state.heatingProgress * 100);
             ctx.fillText(percent + "%", cx, by + 25);
        }

        function handleInput(x, y) {
            const dpr = window.devicePixelRatio || 1;
            const scale = mainCanvas.width / originalWidth; 
            const rx = (x * dpr) / scale; const ry = (y * dpr) / scale;
            const points = (state.viewMode === 'render') ? renderPoints : linePoints;
            const radius = (state.viewMode === 'render') ? renderRadius : lineRadius;
            for (const [name, p] of Object.entries(points)) {
                let r = p.r || radius; 
                const dist = Math.sqrt((rx - p.x)**2 + (ry - p.y)**2);
                if (dist <= r * 1.5) { if (name.includes('Hold')) startHold(); else triggerAction(name); return; }
            }
        }
        mainCanvas.addEventListener('mousedown', e => { const rect = mainCanvas.getBoundingClientRect(); handleInput(e.clientX - rect.left, e.clientY - rect.top); });
        window.addEventListener('mouseup', () => { if(state.holdActive) stopHold(); });
        mainCanvas.addEventListener('touchstart', e => { const rect = mainCanvas.getBoundingClientRect(); const t = e.touches[0]; handleInput(t.clientX - rect.left, t.clientY - rect.top); }, {passive:true});
        window.addEventListener('touchend', () => { if(state.holdActive) stopHold(); });

        const flowCanvas = document.getElementById('flow-canvas');
        const flowCtx = flowCanvas.getContext('2d');
        const FLOW_W = 340; const FLOW_H = 450; 

        function resizeFlowCanvas() {
            const container = document.getElementById('sidebar');
            const dpr = window.devicePixelRatio || 1;
            const cw = container.clientWidth - 20; // Account for margins
            const scale = cw / FLOW_W; 
            
            flowCanvas.width = cw * dpr;
            flowCanvas.height = FLOW_H * scale * dpr;
            flowCanvas.style.width = cw + 'px';
            flowCanvas.style.height = (FLOW_H * scale) + 'px';
            
            flowCtx.setTransform(1, 0, 0, 1, 0, 0); 
            flowCtx.scale(scale * dpr, scale * dpr);
        }
        window.addEventListener('resize', resizeFlowCanvas); resizeFlowCanvas();
        
        function drawFlowchart() {
             const cx = FLOW_W / 2;
             flowCtx.clearRect(0,0,FLOW_W,FLOW_H); 
             // const cx = w/2; // Removed dynamic w calc
             const y1 = 40; const y2 = 130; const y3 = 250;
             const xNorm = 60; const xBoost = 220;
             const xPHeat = 140; // Between Off and Norm (Row 1.5 logic tricky, keeping inline)
             // Re-layout: 
             // Row 1: OFF -> Power Heat -> Normal
             // Row 2: Normal -> Boost Heat -> Boost
             
             // Redefine coordinates for cleaner vertical flow
             const ry1 = 30; // OFF
             const ry2 = 100; // PHeat
             const ry3 = 170; // Normal / Boost Heat / Boost
             const ry4 = 280; // Steam
             
             // Row 3 (Normal / Boost)
             const rxNorm = 70;
             const rxBoost = 270;
             const rxBHeat = 170;

             // Nodes
             const h = 40;
             let offActive = !state.powerOn;
             renderNode(cx, ry1, "OFF", offActive ? 'on' : 'off', 80, 30, offActive);
             
             let pHeatActive = (state.isHeating && state.targetMode === 1);
             renderNode(cx, ry2, "Power Heat\n(8s)", pHeatActive ? 'on' : 'off', 80, 30, pHeatActive);
             
             let normActive = (state.powerOn && state.mode === 1 && !state.isHeating);
             renderNode(rxNorm, ry3, "ON\n(Normal)", normActive ? 'on' : 'off', 80, h, normActive);
             
             let bHeatActive = (state.isHeating && state.targetMode === 2);
             renderNode(rxBHeat, ry3, "Boost Heat\n(8s)", bHeatActive ? 'on' : 'off', 70, 30, bHeatActive);
             
             let boostActive = (state.powerOn && state.mode === 2 && !state.isHeating);
             renderNode(rxBoost, ry3, "ON\n(Boost)", boostActive ? 'on' : 'off', 80, h, boostActive);
             
             let steamNActive = (state.mode === 1 && state.holdActive);
             renderNode(rxNorm, ry4, "STEAM\n(Normal)", steamNActive ? 'on' : 'off', 80, h, steamNActive);
             
             let steamBActive = (state.mode === 2 && state.holdActive);
             renderNode(rxBoost, ry4, "STEAM\n(Boost)", steamBActive ? 'on' : 'off', 80, h, steamBActive);
             
             flowCtx.strokeStyle = "#444444"; flowCtx.fillStyle = "#888888"; 
             flowCtx.font = "italic 10px Segoe UI"; flowCtx.textAlign = "center";

             // Connections
             // Off -> PHeat
             drawLink(cx, ry1+15, cx, ry2-15); 
             flowCtx.fillText("Power", cx+20, (ry1+ry2)/2);
             
             // PHeat -> Normal
             // drawLink(cx, ry2+15, rxNorm, ry3-20); // Center to Left
             flowCtx.beginPath(); flowCtx.moveTo(cx, ry2+15); flowCtx.lineTo(cx, ry3-30); flowCtx.lineTo(rxNorm, ry3-30); flowCtx.lineTo(rxNorm, ry3-20); flowCtx.stroke();

             // Normal -> Boost Heat -> Boost
             drawLink(rxNorm+40, ry3, rxBHeat-35, ry3);
             drawLink(rxBHeat+35, ry3, rxBoost-40, ry3);
             
             // Boost Loop Back
             flowCtx.beginPath(); flowCtx.moveTo(rxBoost, ry3+20); flowCtx.lineTo(rxBoost, ry3+35);
             flowCtx.lineTo(rxNorm, ry3+35); flowCtx.lineTo(rxNorm, ry3+20); flowCtx.stroke();
             flowCtx.fillText("Boost Btn", rxBHeat, ry3+45); // Label on bottom loop

             // Steam
             drawLink(rxNorm, ry3+20, rxNorm, ry4-20);
             drawLink(rxBoost, ry3+20, rxBoost, ry4-20);
             flowCtx.fillText("Hold", rxNorm-15, (ry3+ry4)/2);
             flowCtx.fillText("Hold", rxBoost-15, (ry3+ry4)/2);
        }

        function drawLink(x1, y1, x2, y2) { flowCtx.beginPath(); flowCtx.moveTo(x1, y1); flowCtx.lineTo(x2, y2); flowCtx.stroke(); }
        
        // Helper updated to accept boolean 'active' override instead of tag matching logic inside
        function renderNode(x, y, text, tag, w, h, isActive) {
            const x1 = x - w/2; const y1 = y - h/2;
            const color = isActive ? (text.includes("STEAM") || text.includes("Power Heat") || text.includes("Boost Heat") ? "#ffffff" : "#444444") : "#2b2b2b";
            const textColor = isActive ? (color === "#ffffff" ? "#000000" : "#ffffff") : "#666666";
            const border = isActive ? "#ffffff" : "#444444";
            
            flowCtx.fillStyle = color; flowCtx.strokeStyle = border; flowCtx.lineWidth = 2;
            flowCtx.fillRect(x1, y1, w, h); flowCtx.strokeRect(x1, y1, w, h);
            
            flowCtx.fillStyle = textColor; flowCtx.textAlign = "center"; flowCtx.textBaseline = "middle";
            const lines = text.split("\n");
            for(let i=0; i<lines.length; i++) flowCtx.fillText(lines[i], x, y - ((lines.length-1)*6) + (i*12));
        }

        const ledPower = document.getElementById('led-power'); const ledBoost = document.getElementById('led-boost'); const textStatus = document.getElementById('text-status');
        function updateControls() {
            ledPower.style.backgroundColor = state.powerOn ? '#ffffff' : '#3a3a3a';
            if (state.isHeating) { const v = Math.floor(state.pulseIntensity * 255); const hex = v.toString(16).padStart(2,'0'); ledBoost.style.backgroundColor = `#${hex}${hex}${hex}`; } 
            else { const boostActive = state.powerOn && (state.mode === 2); ledBoost.style.backgroundColor = boostActive ? '#ffffff' : '#3a3a3a'; }
            if (state.powerOn) { textStatus.textContent = state.holdActive ? "STEAMING" : "READY"; textStatus.style.color = state.holdActive ? "#ffffff" : "#00ff00"; } 
            else { textStatus.textContent = "READY"; textStatus.style.color = "#555555"; }
        }
    </script>
</body>
</html>