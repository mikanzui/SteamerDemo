<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Steamer Interactive GUI (v4.0)</title>
    <style>
        body { margin: 0; padding: 0; background-color: #1e1e1e; font-family: 'Segoe UI', sans-serif; color: #eeeeee; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        #controls-bar { background-color: #2b2b2b; padding: 5px 20px; display: flex; justify-content: center; align-items: center; border-bottom: 1px solid #333; flex-shrink: 0; }
        .control-group { display: flex; flex-direction: column; align-items: flex-start; margin: 0 15px; }
        .group-label { font-size: 10px; font-weight: bold; color: #888888; margin-bottom: 8px; text-transform: uppercase; }
        .row-frame { display: flex; align-items: center; }
        button { background-color: #3a3a3a; color: #e0e0e0; border: none; padding: 8px 15px; font-family: 'Segoe UI', sans-serif; font-size: 12px; font-weight: bold; cursor: pointer; margin-right: 5px; min-width: 100px; border-radius: 0px; outline: none; transition: background-color 0.2s; }
        button:hover { background-color: #454545; }
        button:active { background-color: #505050; }
        .separator { width: 1px; background-color: #444444; height: 30px; margin: 0 30px; }
        .led-indicator { width: 10px; height: 10px; border-radius: 50%; background-color: #3a3a3a; border: 1px solid #505050; margin-left: 5px; }
        .text-status { font-size: 11px; font-weight: bold; color: #555555; margin-left: 5px; width: 70px; text-align: center; }
        #main-content { display: flex; flex: 1; overflow: hidden; flex-direction: row; background-color: #000000; }
        #image-area { flex: 1; background-color: #000000; display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative; overflow: hidden; }
        #wrapper { position: relative; } 
        #bg-image { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: fill; pointer-events: none; z-index: 1; display: none; }
        #bg-image-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: fill; pointer-events: none; z-index: 2; display: none; }
        #interaction-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; touch-action: none; cursor: pointer; z-index: 3; }
        #guide-label { margin-top: 10px; color: #666666; font-size: 13px; font-weight: bold; text-align: center; position: absolute; bottom: 10px; width: 100%; pointer-events: none; z-index: 4; }
        #sidebar { width: 300px; background-color: #1a1a1a; display: flex; flex-direction: column; border-left: none; flex-shrink: 0; overflow-y: auto; }
        .sidebar-header { color: white; font-size: 16px; font-weight: bold; padding: 10px 10px 0 10px; background-color: #1a1a1a; }
        .sidebar-sub { color: #666666; font-size: 12px; padding: 5px 10px 5px 10px; }
        #flow-canvas { width: 280px; height: 300px; margin: 0 10px; }
        @media (max-width: 768px) { #main-content { flex-direction: column; } #sidebar { width: 100%; height: 300px; border-top: 1px solid #333; } #flow-canvas { width: 100%; } #controls-bar { flex-wrap: wrap; } .separator { display: none; } .control-group { margin-bottom: 10px; } }
        #login-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #1e1e1e; z-index: 9999; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        #login-box { background-color: #252526; padding: 30px; border: 1px solid #333; border-radius: 5px; text-align: center; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        #login-input { padding: 8px; margin: 10px 0; background-color: #333; border: 1px solid #555; color: white; border-radius: 3px; outline: none; }
        #login-btn { background-color: #007acc; color: white; border: none; padding: 8px 15px; cursor: pointer; border-radius: 3px; font-weight: bold; }
        
        /* Slider Styling (Orange) */
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]:focus { outline: none; }
        /* Webkit (Chrome/Edge/Safari) */
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: #FFA500; cursor: pointer; margin-top: -6px; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #555555; border-radius: 2px; }
        /* Firefox */
        input[type=range]::-moz-range-thumb { height: 16px; width: 16px; border: none; border-radius: 50%; background: #FFA500; cursor: pointer; }
        input[type=range]::-moz-range-track { width: 100%; height: 4px; cursor: pointer; background: #555555; border-radius: 2px; }
    </style>
</head>
<body>
    <div id="login-overlay"><div id="login-box"><h2 style="margin-top: 0;">Restricted Access</h2><p style="color: #ccc; font-size: 14px;">Enter password
    </p><input type="password" id="login-input" placeholder="Password"><br><button id="login-btn" onclick="checkPassword()">Enter</button><p id="login-error" style="color: #ff6b6b; font-size: 12px; margin-top: 10px; display: none;">Incorrect password</p></div></div>

    <div id="controls-bar">
        <div class="control-group"><span class="group-label">MAIN POWER</span><div class="row-frame"><button onclick="triggerAction('Power')">POWER</button><div id="led-power" class="led-indicator"></div></div></div>
        <div class="separator"></div>
        <div class="control-group"><span class="group-label">INTENSITY</span><div class="row-frame"><button onclick="triggerAction('Boost')">BOOST</button><div id="led-boost" class="led-indicator"></div></div></div>
        <div class="separator"></div>
        <div class="control-group"><span class="group-label">OPERATION</span><div class="row-frame"><button onmousedown="startHold()" onmouseup="stopHold()" ontouchstart="startHold(event)" ontouchend="stopHold(event)" style="width: 140px;">HOLD TO STEAM</button><span id="text-status" class="text-status">READY</span></div></div>
        <div class="separator"></div>
        <div class="control-group"><span class="group-label">VIEW MODE</span><div class="row-frame"><button id="btn-view" onclick="toggleViewMode()">SWITCH TO<br>RENDERS</button></div></div>
    </div>

    <div id="main-content">
        <div id="image-area">
            <div id="wrapper">
                <img id="bg-image" draggable="false">
                <img id="bg-image-overlay" draggable="false">
                <canvas id="interaction-canvas"></canvas>
            </div>
            <div id="guide-label">INTERACTIVE MODE: Click the buttons on the product image (Main or Side view) to operate.</div>
        </div>
        <div id="sidebar">
            <div class="sidebar-header">State Overview</div><div class="sidebar-sub">Logic Decision Tree:</div><canvas id="flow-canvas"></canvas>
            
            <div class="sidebar-header" style="border-top: 1px solid #333; margin-top: 0;">LED Pulse Behaviour</div>
            <div class="sidebar-sub">Adjust pulse animation</div>
            <div style="padding: 0 15px 10px 15px;">
                <!-- Frequency -->
                <div style="display:flex; justify-content:space-between; color:#888; font-size:11px; margin-bottom:5px;">
                    <span>Frequency</span><span id="val-freq">0.6 Hz</span>
                </div>
                <input type="range" id="param-freq" min="0.1" max="3.0" step="0.1" value="0.6" style="width:100%" oninput="updateParams()">
                
                <!-- Min Intensity -->
                <div style="display:flex; justify-content:space-between; color:#888; font-size:11px; margin-top:15px; margin-bottom:5px;">
                    <span>Min Intensity</span><span id="val-min">0.10</span>
                </div>
                <input type="range" id="param-min" min="0.0" max="1.0" step="0.05" value="0.1" style="width:100%" oninput="updateParams()">
                
                <!-- Max Intensity -->
                <div style="display:flex; justify-content:space-between; color:#888; font-size:11px; margin-top:15px; margin-bottom:5px;">
                    <span>Max Intensity</span><span id="val-max">1.00</span>
                </div>
                <input type="range" id="param-max" min="0.0" max="1.0" step="0.05" value="1.0" style="width:100%" oninput="updateParams()">

                <!-- Dwell -->
                <div style="display:flex; justify-content:space-between; color:#888; font-size:11px; margin-top:15px; margin-bottom:5px;">
                    <span>Dwell (Pause)</span><span id="val-dwell">0.0s</span>
                </div>
                <input type="range" id="param-dwell" min="0" max="3.0" step="0.1" value="0" style="width:100%" oninput="updateParams()">

                <!-- Graph -->
                <div style="color:#888; font-size:11px; margin-top:20px; margin-bottom:5px;">Pulse Preview (Full Cycle)</div>
                <canvas id="pulse-graph" width="270" height="100" style="background-color:#222; border:1px solid #333; width:100%;"></canvas>
            </div>
        </div>
    </div>

    <script>
        function checkPassword() { if (document.getElementById('login-input').value === 'steamer2024') { document.getElementById('login-overlay').style.display = 'none'; startLoop(); } else { document.getElementById('login-error').style.display = 'block'; document.getElementById('login-input').value = ''; } }
        document.getElementById('login-input').addEventListener('keypress', e => { if (e.key === 'Enter') checkPassword(); });

        const originalWidth = 4000;
        const originalHeight = 2110;
        const linePoints = { 
            "Power": { x: 597, y: 669 }, 
            "Boost": { x: 597, y: 800 }, 
            "Hold": { x: 1776, y: 877, r: 60 }, 
            "Steam": { x: 3477, y: 325 }, 
            "Power_Side": { x: 2634, y: 674 }, 
            "Boost_Side": { x: 2637, y: 797 },
            "Hold_Side": { x: 2914, y: 872, r: 60 }
        };
        const renderPoints = {
            "Power": { x: 898, y: 833 },
            "Boost": { x: 898, y: 944 },
            "Hold": { x: 1931, y: 1008, r: 150 }, // Increased Radius
            "Power_Side": { x: 2688, y: 809 },
            "Boost_Side": { x: 2688, y: 925 },
            "Hold_Side": { x: 2883, y: 987, r: 150 } // Increased Radius
        };
        const lineRadius = 50; const renderRadius = 45; // Reverted base radius (Steam has explicit override)

        const images = {};
        const imageFiles = { 'line': 'steamer.png', 'alloff': 'Renders/alloff.jpg', 'on': 'Renders/on.jpg', 'onwithsteam': 'Renders/onwithsteam.jpg', 'onwithboost': 'Renders/onwithboost.jpg', 'onboostwithsteam': 'Renders/onboostwithsteam.jpg' };
        for (const [key, src] of Object.entries(imageFiles)) { images[key] = new Image(); images[key].src = src; }

        let state = { powerOn: false, mode: 1, targetMode: 1, holdActive: false, isHeating: false, heatingStartTime: 0, heatingDuration: 8.0, heatingProgress: 0.0, pulseIntensity: 0.0, pulseStartTime: 0, viewMode: 'line' };
        let pulseParams = { freq: 0.6, min: 0.1, max: 1.0, dwell: 0 };

        function updateParams() {
            pulseParams.freq = parseFloat(document.getElementById('param-freq').value);
            pulseParams.min = parseFloat(document.getElementById('param-min').value);
            pulseParams.max = parseFloat(document.getElementById('param-max').value);
            pulseParams.dwell = parseFloat(document.getElementById('param-dwell').value);
            
            document.getElementById('val-freq').textContent = pulseParams.freq.toFixed(1) + " Hz";
            document.getElementById('val-min').textContent = pulseParams.min.toFixed(2);
            document.getElementById('val-max').textContent = pulseParams.max.toFixed(2);
            document.getElementById('val-dwell').textContent = pulseParams.dwell.toFixed(1) + "s";
            
            drawPulseGraph();
        }

        function drawPulseGraph() {
            const canvas = document.getElementById('pulse-graph');
            if(!canvas) return;
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.clearRect(0, 0, w, h);
            
            // Draw Background Grid (Subtle)
            ctx.strokeStyle = "#333"; ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, h * (1 - pulseParams.min)); ctx.lineTo(w, h * (1 - pulseParams.min)); // Min line
            ctx.moveTo(0, h * (1 - pulseParams.max)); ctx.lineTo(w, h * (1 - pulseParams.max)); // Max line
            ctx.stroke();

            // Total Duration (X-Axis) = state.heatingDuration (default 8s if not heating) or 8s baseline?
            // User request: "full range of time to be the time it takes for the loading bar"
            // We use state.heatingDuration. If strictly 0 (not started), maybe default to 8.0?
            let totalDuration = state.heatingDuration || 8.0; 
            
            ctx.strokeStyle = "#FFA500";
            ctx.lineWidth = 2;
            ctx.beginPath();

            const freq = pulseParams.freq;
            let dwellFrac = pulseParams.dwell * freq;
            if (dwellFrac > 1.0) dwellFrac = 1.0;
            const activeTime = 1.0 - dwellFrac;
            const riseTime = activeTime / 2;
            
            // Plot points across canvas width
            for (let x = 0; x <= w; x++) {
                // Map x to time
                const t = (x / w) * totalDuration;
                
                // Calculate Pulse (Logic copied from loop)
                const cyclePos = t * freq;
                const p = cyclePos - Math.floor(cyclePos);
                
                let normalized = 0.0;
                
                if (p < riseTime) {
                    const prog = p / riseTime;
                    const angle = -Math.PI / 2 + (prog * Math.PI);
                    normalized = (Math.sin(angle) + 1) / 2;
                } else if (p < riseTime + dwellFrac) {
                    normalized = 1.0;
                } else {
                    const activeP = p - (riseTime + dwellFrac);
                    const prog = activeP / riseTime; 
                    // Note: In loop, calculation was:
                    // const prog = (p - (riseTime + dwellFrac)) / riseTime;
                    // const angle = Math.PI / 2 + (prog * Math.PI);
                    // This resulted in sine fall. Replicating exactly:
                    const angle = Math.PI / 2 + (prog * Math.PI);
                    normalized = (Math.sin(angle) + 1) / 2;
                }

                const intensity = pulseParams.min + (normalized * (pulseParams.max - pulseParams.min));
                // If min > max, clamp to max (safety from loop)
                const val = (pulseParams.min > pulseParams.max) ? pulseParams.max : intensity;
                
                // Map intensity (0..1) to Y (h..0)
                const y = h - (val * h); 
                
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        function triggerAction(name) {
            if (name.includes('Power')) { 
                if (!state.powerOn) { 
                    // Turn ON -> Start Heating for Normal Mode (1)
                    state.powerOn = true; 
                    startHeating(1, 8.0); 
                } else { 
                    // Turn OFF
                    state.powerOn = false; 
                    state.mode = 1; 
                    state.holdActive = false; 
                    cancelHeating(); 
                } 
            }
            else if (name.includes('Boost')) { 
                if (state.powerOn) { 
                    if (state.mode === 1) {
                         if (state.isHeating) {
                             // Handle toggling during heating
                             if (state.targetMode === 1) {
                                 // Currently Powering Up -> Add Boost
                                 state.targetMode = 2;
                                 state.heatingDuration = 16.0;
                             } else if (state.targetMode === 2) {
                                 // Currently Heating to Boost -> Cancel Boost
                                 if (state.heatingDuration > 8.0) {
                                     // Sequential Mode (16s)
                                     const el = (performance.now()/1000) - state.heatingStartTime;
                                     if (el < 8.0) {
                                         // Still in Power Phase -> Revert to simple Power Up
                                         state.targetMode = 1;
                                         state.heatingDuration = 8.0;
                                     } else {
                                         // Already in Boost Phase -> Stop and stay Normal
                                         cancelHeating();
                                         state.mode = 1; 
                                     }
                                 } else {
                                     // Standard Heating (8s) -> Cancel
                                     cancelHeating();
                                     state.mode = 1; 
                                 }
                             }
                         } else {
                             // Steady State Normal -> Start Heating to Boost
                             startHeating(2, 8.0); 
                         }
                    } else {
                        state.mode = 1; // Return to Normal immediately
                    }
                } 
            }
            updateControls();
        }
        function startHeating(target, duration) { 
            state.isHeating = true; 
            state.targetMode = target;
            state.heatingDuration = duration;
            state.heatingStartTime = performance.now() / 1000; 
            // Sync pulse start time if we are starting a fresh heating cycle
            // This ensures the sine wave always starts at the correct phase
            state.pulseStartTime = state.heatingStartTime;
            state.heatingProgress = 0.0; 
        }
        function cancelHeating() { state.isHeating = false; updateControls(); }
        function finishHeating() { 
            state.isHeating = false; 
            state.mode = state.targetMode; 
            updateControls();
        }
        function startHold(e) { 
            if (e) e.preventDefault(); 
            // Block steam during initial Power On heating (targetMode 1)
            // Allow steam during Boost heating (targetMode 2)
            if (state.isHeating && state.targetMode === 1) return;

            if (state.powerOn) { state.holdActive = true; updateControls(); } 
        }
        function stopHold(e) { state.holdActive = false; updateControls(); }
        function toggleViewMode() { state.viewMode = (state.viewMode === 'line') ? 'render' : 'line'; document.getElementById('btn-view').innerHTML = state.viewMode === 'line' ? "SWITCH TO<br>RENDERS" : "SWITCH TO<br>LINES"; }

        function startLoop() { requestAnimationFrame(loop); }
        function loop(timestamp) {
            const now = timestamp / 1000;
            
            // 1. Handle Heating Logic
            if (state.isHeating) {
                // Update: Do not cancel heating if holding steam (state.holdActive)
                // Only cancel if power is turned off
                if (!state.powerOn) {
                    cancelHeating();
                } else {
                    const elapsed = now - state.heatingStartTime;
                    state.heatingProgress = Math.min(1.0, elapsed / state.heatingDuration); 
                    if (state.heatingProgress >= 1.0) finishHeating();
                }
            }

            // 2. Handle Pulse Logic
            // Apply when: Heating Only (Reverted "Steady Boost Pulse")
            const shouldPulse = state.isHeating;

            if (shouldPulse) {
                // If we are in Boost Mode Steady (not heating), and we don't have a valid pulseStartTime,
                // we should probably sync it. But ideally it carries over from heating.
                if (state.pulseStartTime === 0) state.pulseStartTime = now;

                const elapsed = now - state.pulseStartTime;
                const freq = pulseParams.freq;
                const t = elapsed * freq; 
                const p = t - Math.floor(t); 
                
                let dwellFrac = pulseParams.dwell * freq;
                if (dwellFrac > 1.0) dwellFrac = 1.0;
                const activeTime = 1.0 - dwellFrac;
                const riseTime = activeTime / 2;
                
                let normalized = 0.0;
                
                if (p < riseTime) {
                    const prog = p / riseTime;
                    const angle = -Math.PI / 2 + (prog * Math.PI);
                    normalized = (Math.sin(angle) + 1) / 2;
                } else if (p < riseTime + dwellFrac) {
                    normalized = 1.0;
                } else {
                    const prog = (p - (riseTime + dwellFrac)) / riseTime;
                    const angle = Math.PI / 2 + (prog * Math.PI);
                    normalized = (Math.sin(angle) + 1) / 2;
                }
                
                state.pulseIntensity = pulseParams.min + (normalized * (pulseParams.max - pulseParams.min));
                if (pulseParams.min > pulseParams.max) state.pulseIntensity = pulseParams.max;
            } else {
                state.pulseIntensity = 0.0;
                // state.pulseStartTime = 0; // Don't reset, allows pausing phase? No, continuous is better.
            }

            updateControls(); 
            drawMain(); drawFlowchart(); requestAnimationFrame(loop);
        }

        const mainCanvas = document.getElementById('interaction-canvas');
        const mainCtx = mainCanvas.getContext('2d');
        const bgImgElement = document.getElementById('bg-image');
        const bgImgOverlay = document.getElementById('bg-image-overlay');
        const wrapper = document.getElementById('wrapper');

        function resizeMainCanvas() {
            const container = document.getElementById('image-area');
            const dpr = window.devicePixelRatio || 1;
            const cw = container.clientWidth; const ch = container.clientHeight;
            const ratio = originalWidth / originalHeight;
            let newW = cw; let newH = cw / ratio;
            if (newH > ch) { newH = ch; newW = ch * ratio; }
            
            // Resize wrapper to hold both
            wrapper.style.width = newW + 'px';
            wrapper.style.height = newH + 'px';

            mainCanvas.width = newW * dpr; mainCanvas.height = newH * dpr;
            mainCtx.imageSmoothingEnabled = true; mainCtx.imageSmoothingQuality = 'high';
            // Note: bgImgElement sizes automatically to wrapper 100%
        }
        window.addEventListener('resize', resizeMainCanvas); resizeMainCanvas();
        // Initial drawing of graph
        setTimeout(drawPulseGraph, 100);

        let currentBgSrc = "";
        let currentOverlaySrc = "";

        function drawMain() {
            mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
            let bgImage = images.line;
            let overlayImage = null; // Default no overlay
            let overlayOpacity = 0.0;
            
            // Determine Render Images
            if (state.viewMode === 'render') {
                if (state.powerOn) {
                    if (state.isHeating) {
                        // Heating: Pulse Effect
                        // Use calculated intensity (0.0 - 1.0)
                        const pulseVal = state.pulseIntensity; 
                        
                        // Handle STEAM during heating
                        if (state.holdActive) {
                            // If holding steam while heating, show the steam for the CURRENT mode.
                            // e.g. If heating to Boost (Mode 1->2), show Mode 1 steam (smaller).
                            if (state.mode === 2) {
                                bgImage = images.onboostwithsteam;
                            } else {
                                bgImage = images.onwithsteam;
                            }
                            // Disable overlay to ensure steam is visible (full renders are opaque)
                            overlayImage = null;
                        } 
                        else if (state.targetMode === 2) {
                             // Boost Heating - Simplified Overlay Method
                             if (state.heatingDuration > 8.0) {
                                 const elapsed = (performance.now()/1000) - state.heatingStartTime;
                                 if (elapsed < 8.0) {
                                     // Phase 1: Power Up Phase
                                     bgImage = images.alloff;
                                     overlayImage = images.onwithboost;
                                     overlayOpacity = pulseVal;
                                 } else {
                                     // Phase 2: Boost Heat Phase
                                     bgImage = images.on;
                                     overlayImage = images.onwithboost;
                                     overlayOpacity = pulseVal;
                                 }
                             } else {
                                 // Regular Boost Heat (from Steady)
                                 bgImage = images.on;
                                 overlayImage = images.onwithboost;
                                 overlayOpacity = pulseVal;
                             }
                        } else {
                             // Power Heating: Base=OFF, Overlay=ON
                             bgImage = images.alloff;
                             overlayImage = images.on;
                             overlayOpacity = pulseVal; 
                        }
                    } else {
                        // Steady State
                        if (state.mode === 2) {
                            if (state.holdActive) {
                                bgImage = images.onboostwithsteam;
                            } else {
                                // REVERT: Steady Boost = Solid ON+BOOST
                                bgImage = images.onwithboost;
                            }
                        } else {
                            bgImage = state.holdActive ? images.onwithsteam : images.on;
                        }
                    }
                } else {
                    bgImage = images.alloff;
                }
            }

            // Render to Canvas (Double Buffer Strategy)
            // We draw both the Base and the Overlay directly to the canvas.
            // This ensures pixel-perfect alignment and identical scaling, preventing phasing/flashing.
            
            mainCtx.globalCompositeOperation = 'source-over';
            
            // 1. Draw Base Layer
            if (bgImage) {
                 mainCtx.globalAlpha = 1.0;
                 mainCtx.drawImage(bgImage, 0, 0, mainCanvas.width, mainCanvas.height);
            }

            // 2. Draw Overlay Layer
            if (overlayImage) {
                mainCtx.save();
                mainCtx.globalAlpha = overlayOpacity;
                mainCtx.drawImage(overlayImage, 0, 0, mainCanvas.width, mainCanvas.height);
                mainCtx.restore();
            }

            // Tint: Use Canvas Filter (Invert) if needed for separate implementation, 
            // but CSS filter was on the IMG tag. We need to Re-implement Tint for Canvas if line mode.
            if (state.viewMode === 'line' && bgImage === images.line) {
                 // For line mode white-on-black, we invert the canvas content
                 // Simplified: Since we just drew the image, we can just filter it or use compositing.
                 // However, "filter = invert(1)" is expensive in canvas on some browsers.
                 // Alternative: `globalCompositeOperation = 'difference'` against white background?
                 
                 // Let's stick to the simplest method: CSS Filter on the CANVAS itself.
                 mainCanvas.style.filter = 'invert(1)';
            } else {
                 mainCanvas.style.filter = 'none';
            }

            const scale = mainCanvas.width / originalWidth;

            if (state.viewMode === 'line' && state.powerOn) {
                // Line View Logic (Unchanged)
                mainCtx.globalCompositeOperation = 'screen';
                
                // Active Logic for Power Glow
                let powerInt = 1.0;
                // If Heating Normal (Target 1) -> Pulse
                // If Heating Boost from Cold (Target 2, Duration 16):
                //    - Elapsed < 8: Pulse
                //    - Elapsed >= 8: Solid (1.0)
                if (state.isHeating) {
                    if (state.targetMode === 1) powerInt = state.pulseIntensity;
                    else if (state.heatingDuration > 8.0) {
                        const el = (performance.now()/1000) - state.heatingStartTime;
                        if (el < 8.0) powerInt = state.pulseIntensity;
                        else powerInt = 1.0;
                    }
                }
                drawGlow(mainCtx, linePoints.Power.x, linePoints.Power.y, scale, powerInt);
                drawGlow(mainCtx, linePoints.Power_Side.x, linePoints.Power_Side.y, scale, powerInt);
                
                // Active Logic for Boost Glow
                if (state.mode === 2 || (state.isHeating && state.targetMode === 2)) {
                    // Logic: Pulse only during Boost Heating. Solid for Steady Boost.
                    let boostInt = 1.0;
                    if (state.isHeating && state.targetMode === 2) boostInt = state.pulseIntensity;
                    else if (state.mode === 2) boostInt = 1.0; 
                    
                    drawGlow(mainCtx, linePoints.Boost.x, linePoints.Boost.y, scale, boostInt);
                    drawGlow(mainCtx, linePoints.Boost_Side.x, linePoints.Boost_Side.y, scale, boostInt);
                }
                if (state.holdActive) {
                     const isBoost = (state.mode === 2);
                     drawSteamCloud(mainCtx, linePoints.Steam.x * scale, linePoints.Steam.y * scale, "white", isBoost, scale);
                }
                mainCtx.globalCompositeOperation = 'source-over';
            }
            if (state.isHeating) drawHeatingOverlay(mainCtx, scale);
        }

        function drawGlow(ctx, x, y, scale, intensity) {
            const r = lineRadius * scale * 1.6; const gx = x * scale; const gy = y * scale;
            const grad = ctx.createRadialGradient(gx, gy, 0, gx, gy, r);
            grad.addColorStop(0, `rgba(255, 255, 255, ${intensity})`); grad.addColorStop(1, `rgba(255, 255, 255, 0)`);
            ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(gx, gy, r, 0, Math.PI * 2); ctx.fill();
        }
        
        function drawSteamCloud(ctx, x, y, color, isBoost, scaleBase) { 
            ctx.save();
            // Move up slightly to compensate for rotation
            ctx.translate(x, y - (25 * scaleBase));
            ctx.rotate(-10 * Math.PI / 180); // Rotate -10 degrees (Side output)
            
            const boostScale = isBoost ? 1.4 : 1.0;
            const finalScale = scaleBase * boostScale * 2.0; // DOUBLE SIZE
            // Soft Blur Filter
            ctx.filter = `blur(${8 * finalScale}px)`; 
            // Body (Centered at 0,0 after translate)
            ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
            ctx.beginPath(); ctx.ellipse(0, 0, 60 * finalScale, 30 * finalScale, 0, 0, Math.PI * 2); ctx.fill();
            // Core Line
            const width = (isBoost ? 180 : 120) * finalScale;
            ctx.lineWidth = (isBoost ? 10 : 6) * finalScale; ctx.strokeStyle = "rgba(255, 255, 255, 0.6)"; ctx.lineCap = 'round';
            ctx.beginPath(); ctx.moveTo(-width/2, 0); ctx.lineTo(width/2, 0); ctx.stroke();
            ctx.restore();
        }

        function drawHeatingOverlay(ctx, scale) {
             const cx = ctx.canvas.width / 2; const yTop = 10; 
             const w = 300; 
             // Height depends on mode
             const isLongHeat = (state.heatingDuration > 8.0);
             const h = isLongHeat ? 140 : 100;
             
             ctx.fillStyle = "#2b2b2b"; ctx.strokeStyle = "#ffffff"; ctx.lineWidth = 2;
             ctx.fillRect(cx - w/2, yTop, w, h); ctx.strokeRect(cx - w/2, yTop, w, h);
             ctx.fillStyle = "#ffffff"; ctx.font = "bold 16px Segoe UI"; ctx.textAlign = "center";
             const title = "HEATING UP...";
             ctx.fillText(title, cx, yTop + 35);
             
             const barW = 250; const barH = 12; const bx = cx - barW/2; 
             
             if (isLongHeat) {
                 // 16s Heating (Power then Boost)
                 // Use elapsed time relative to start
                 const elapsed = (performance.now() / 1000) - state.heatingStartTime;
                 
                 // Bar 1: Power (0-8s)
                 const p1 = Math.min(1.0, elapsed / 8.0);
                 const by1 = yTop + 55;
                 ctx.fillStyle = "#444444"; ctx.fillRect(bx, by1, barW, barH);
                 if (p1 > 0) { ctx.fillStyle = "#ffffff"; ctx.fillRect(bx, by1, barW * p1, barH); }
                 
                 // Label 1
                 ctx.fillStyle = "#aaaaaa"; ctx.font = "12px Segoe UI";
                 ctx.fillText("POWER: " + Math.floor(p1 * 100) + "%", cx, by1 + 25);
                 
                 // Bar 2: Boost (8-16s)
                 const p2 = Math.max(0.0, Math.min(1.0, (elapsed - 8.0) / 8.0));
                 const by2 = by1 + 40;
                 ctx.fillStyle = "#444444"; ctx.fillRect(bx, by2, barW, barH);
                 if (p2 > 0) { ctx.fillStyle = "#FFA500"; ctx.fillRect(bx, by2, barW * p2, barH); }
                 
                 // Label 2
                 ctx.fillText("BOOST: " + Math.floor(p2 * 100) + "%", cx, by2 + 25);
                 
             } else {
                 // Standard 8s Limit
                 const by = yTop + 55;
                 ctx.fillStyle = "#444444"; ctx.fillRect(bx, by, barW, barH);
                 
                 let fillColor = "#ffffff";
                 let labelPrefix = "POWER: ";

                 if (state.targetMode === 2) {
                     fillColor = "#FFA500";
                     labelPrefix = "BOOST: ";
                 }

                 const fillW = barW * state.heatingProgress; 
                 ctx.fillStyle = fillColor; 
                 ctx.fillRect(bx, by, fillW, barH);
                 
                 ctx.fillStyle = "#aaaaaa"; ctx.font = "12px Segoe UI";
                 const percent = Math.floor(state.heatingProgress * 100);
                 ctx.fillText(labelPrefix + percent + "%", cx, by + 25);
             }
        }

        function handleInput(x, y) {
            const dpr = window.devicePixelRatio || 1;
            const scale = mainCanvas.width / originalWidth; 
            const rx = (x * dpr) / scale; const ry = (y * dpr) / scale;
            const points = (state.viewMode === 'render') ? renderPoints : linePoints;
            const radius = (state.viewMode === 'render') ? renderRadius : lineRadius;
            for (const [name, p] of Object.entries(points)) {
                let r = p.r || radius; 
                const dist = Math.sqrt((rx - p.x)**2 + (ry - p.y)**2);
                if (dist <= r * 1.5) { if (name.includes('Hold')) startHold(); else triggerAction(name); return; }
            }
        }
        mainCanvas.addEventListener('mousedown', e => { const rect = mainCanvas.getBoundingClientRect(); handleInput(e.clientX - rect.left, e.clientY - rect.top); });
        window.addEventListener('mouseup', () => { if(state.holdActive) stopHold(); });
        mainCanvas.addEventListener('touchstart', e => { const rect = mainCanvas.getBoundingClientRect(); const t = e.touches[0]; handleInput(t.clientX - rect.left, t.clientY - rect.top); }, {passive:true});
        window.addEventListener('touchend', () => { if(state.holdActive) stopHold(); });

        const flowCanvas = document.getElementById('flow-canvas');
        const flowCtx = flowCanvas.getContext('2d');
        const FLOW_W = 340; const FLOW_H = 300; 

        function resizeFlowCanvas() {
            const container = document.getElementById('sidebar');
            const dpr = window.devicePixelRatio || 1;
            const cw = container.clientWidth - 20; // Account for margins
            const scale = cw / FLOW_W; 
            
            flowCanvas.width = cw * dpr;
            flowCanvas.height = FLOW_H * scale * dpr;
            flowCanvas.style.width = cw + 'px';
            flowCanvas.style.height = (FLOW_H * scale) + 'px';
            
            flowCtx.setTransform(1, 0, 0, 1, 0, 0); 
            flowCtx.scale(scale * dpr, scale * dpr);
        }
        window.addEventListener('resize', resizeFlowCanvas); resizeFlowCanvas();
        
        function drawFlowchart() {
             const cx = FLOW_W / 2;
             flowCtx.clearRect(0,0,FLOW_W,FLOW_H); 
             // const cx = w/2; // Removed dynamic w calc
             const y1 = 40; const y2 = 130; const y3 = 250;
             const xNorm = 60; const xBoost = 220;
             const xPHeat = 140; // Between Off and Norm (Row 1.5 logic tricky, keeping inline)
             // Re-layout: 
             // Row 1: OFF -> Power Heat -> Normal
             // Row 2: Normal -> Boost Heat -> Boost
             
             // Redefine coordinates for cleaner vertical flow
             const ry1 = 30; // OFF
             const ry2 = 100; // PHeat
             const ry3 = 170; // Normal / Boost Heat / Boost
             const ry4 = 240; // Steam
             
             // Row 3 (Normal / Boost)
             const rxNorm = 70;
             const rxBoost = 270;
             const rxBHeat = 170;

             // Nodes
             const h = 40;
             let offActive = !state.powerOn;
             renderNode(cx, ry1, "OFF", offActive ? 'on' : 'off', 80, 30, offActive);
             
             let pHeatActive = (state.isHeating && state.targetMode === 1);
             renderNode(cx, ry2, "Power Heat", pHeatActive ? 'on' : 'off', 80, 30, pHeatActive);
             
             let normActive = (state.powerOn && state.mode === 1 && !state.isHeating);
             renderNode(rxNorm, ry3, "ON\n(Normal)", normActive ? 'on' : 'off', 80, h, normActive);
             
             let bHeatActive = (state.isHeating && state.targetMode === 2);
             renderNode(rxBHeat, ry3, "Boost Heat", bHeatActive ? 'on' : 'off', 70, 30, bHeatActive);
             
             let boostActive = (state.powerOn && state.mode === 2 && !state.isHeating);
             renderNode(rxBoost, ry3, "ON\n(Boost)", boostActive ? 'on' : 'off', 80, h, boostActive);
             
             let steamNActive = (state.mode === 1 && state.holdActive);
             renderNode(rxNorm, ry4, "STEAM\n(Normal)", steamNActive ? 'on' : 'off', 80, h, steamNActive);
             
             let steamBActive = (state.mode === 2 && state.holdActive);
             renderNode(rxBoost, ry4, "STEAM\n(Boost)", steamBActive ? 'on' : 'off', 80, h, steamBActive);
             
             flowCtx.strokeStyle = "#444444"; flowCtx.fillStyle = "#888888"; 
             flowCtx.font = "italic 10px Segoe UI"; flowCtx.textAlign = "center";

             // Connections
             // Off -> PHeat
             drawLink(cx, ry1+15, cx, ry2-15); 
             flowCtx.fillText("Power", cx+20, (ry1+ry2)/2);
             
             // PHeat -> Normal
             // drawLink(cx, ry2+15, rxNorm, ry3-20); // Center to Left
             flowCtx.beginPath(); flowCtx.moveTo(cx, ry2+15); flowCtx.lineTo(cx, ry3-30); flowCtx.lineTo(rxNorm, ry3-30); flowCtx.lineTo(rxNorm, ry3-20); flowCtx.stroke();

             // Normal -> Boost Heat -> Boost
             drawLink(rxNorm+40, ry3, rxBHeat-35, ry3);
             drawLink(rxBHeat+35, ry3, rxBoost-40, ry3);
             
             // Boost Loop Back
             flowCtx.beginPath(); flowCtx.moveTo(rxBoost, ry3+20); flowCtx.lineTo(rxBoost, ry3+35);
             flowCtx.lineTo(rxNorm, ry3+35); flowCtx.lineTo(rxNorm, ry3+20); flowCtx.stroke();
             flowCtx.fillText("Boost Btn", rxBHeat, ry3+45); // Label on bottom loop

             // Steam
             drawLink(rxNorm, ry3+20, rxNorm, ry4-20);
             drawLink(rxBoost, ry3+20, rxBoost, ry4-20);
             flowCtx.fillText("Hold", rxNorm-15, (ry3+ry4)/2);
             flowCtx.fillText("Hold", rxBoost-15, (ry3+ry4)/2);
        }

        function drawLink(x1, y1, x2, y2) { flowCtx.beginPath(); flowCtx.moveTo(x1, y1); flowCtx.lineTo(x2, y2); flowCtx.stroke(); }
        
        // Helper updated to accept boolean 'active' override instead of tag matching logic inside
        function renderNode(x, y, text, tag, w, h, isActive) {
            const x1 = x - w/2; const y1 = y - h/2;
            
            let fill = "#2b2b2b";
            let textCol = "#666666";
            let border = "#444444";
            
            if (isActive) {
                border = "#ffffff";
                textCol = "#000000"; // Default active text
                
                if (text.includes("OFF")) {
                    fill = "#555555";
                    textCol = "#ffffff";
                } else if (text.includes("STEAM")) {
                    fill = "#00aaaa"; // Cyan
                } else if (text.includes("Boost")) {
                    fill = "#d18c02"; // Orange
                } else if (text.includes("Normal") || text.includes("Power")) {
                    fill = "#00aa00"; // Green
                } else {
                    fill = "#ffffff";
                }
            }
            
            flowCtx.fillStyle = fill; flowCtx.strokeStyle = border; flowCtx.lineWidth = 2;
            flowCtx.fillRect(x1, y1, w, h); flowCtx.strokeRect(x1, y1, w, h);
            
            flowCtx.fillStyle = textCol; flowCtx.textAlign = "center"; flowCtx.textBaseline = "middle";
            const lines = text.split("\n");
            for(let i=0; i<lines.length; i++) flowCtx.fillText(lines[i], x, y - ((lines.length-1)*6) + (i*12));
        }

        const ledPower = document.getElementById('led-power'); const ledBoost = document.getElementById('led-boost'); const textStatus = document.getElementById('text-status');
        function updateControls() {
            // Power LED (Green #00ff00)
            if (state.powerOn) {
                // Determine if pulsing
                let pulsing = false;
                if (state.isHeating) {
                    if (state.targetMode === 1) pulsing = true;
                    else if (state.targetMode === 2 && state.heatingDuration > 8.0) {
                        const el = (performance.now()/1000) - state.heatingStartTime;
                        if (el < 8.0) pulsing = true;
                    }
                }
                
                if (pulsing) {
                    // Pulse Green
                    const v = Math.floor(state.pulseIntensity * 255);
                    ledPower.style.backgroundColor = `rgb(0, ${v}, 0)`;
                } else {
                    ledPower.style.backgroundColor = '#00ff00';
                }
            } else {
                ledPower.style.backgroundColor = '#3a3a3a';
            }

            // Boost LED (Orange #FFA500)
            if (state.powerOn) {
                // BUG FIX: Reverted "Steady Pulse" behavior.
                // Only pulse if actively Heating to boost.
                let pulsing = false;
                if (state.isHeating && state.targetMode === 2) {
                     pulsing = true;
                     // Handle Sequential Logic (16s)
                     if (state.heatingDuration > 8.0) {
                         const el = (performance.now()/1000) - state.heatingStartTime;
                         if (el < 8.0) pulsing = false; // Still in Power Phase
                     }
                }
                
                if (pulsing) {
                    // Pulse Orange
                    const v = Math.floor(state.pulseIntensity * 255);
                    const g = Math.floor(v * 0.65); // Maintain orange ratio
                    ledBoost.style.backgroundColor = `rgb(${v}, ${g}, 0)`;
                } else if (state.mode === 2) {
                    // Solid Orange for Steady Boost
                    ledBoost.style.backgroundColor = '#FFA500';
                } else {
                    ledBoost.style.backgroundColor = '#3a3a3a';
                }
            } else {
                ledBoost.style.backgroundColor = '#3a3a3a';
            }

            // Status Text
            if (state.powerOn) { 
                if (state.holdActive) {
                    textStatus.textContent = "STEAMING"; 
                    textStatus.style.color = "#00aaaa"; // Cyan
                } else {
                    textStatus.textContent = "READY"; 
                    textStatus.style.color = "#00ff00"; // Green
                }
            } else { 
                textStatus.textContent = "STANDBY"; 
                textStatus.style.color = "#555555"; 
            }
        }
    </script>
</body>
</html>