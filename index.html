<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Steamer Interactive GUI (v2)</title>
    <style>
        body { margin: 0; padding: 0; background-color: #1e1e1e; font-family: 'Segoe UI', sans-serif; color: #eeeeee; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        #controls-bar { background-color: #2b2b2b; padding: 5px 20px; display: flex; justify-content: center; align-items: center; border-bottom: 1px solid #333; flex-shrink: 0; }
        .control-group { display: flex; flex-direction: column; align-items: flex-start; margin: 0 15px; }
        .group-label { font-size: 10px; font-weight: bold; color: #888888; margin-bottom: 8px; text-transform: uppercase; }
        .row-frame { display: flex; align-items: center; }
        button { background-color: #3a3a3a; color: #e0e0e0; border: none; padding: 8px 15px; font-family: 'Segoe UI', sans-serif; font-size: 12px; font-weight: bold; cursor: pointer; margin-right: 5px; min-width: 100px; border-radius: 0px; outline: none; transition: background-color 0.2s; }
        button:hover { background-color: #454545; }
        button:active { background-color: #505050; }
        .separator { width: 1px; background-color: #444444; height: 30px; margin: 0 30px; }
        .led-indicator { width: 10px; height: 10px; border-radius: 50%; background-color: #3a3a3a; border: 1px solid #505050; margin-left: 5px; }
        .text-status { font-size: 11px; font-weight: bold; color: #555555; margin-left: 5px; width: 70px; text-align: center; }
        #main-content { display: flex; flex: 1; overflow: hidden; flex-direction: row; background-color: #000000; }
        #image-area { flex: 1; background-color: #000000; display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative; overflow: hidden; }
        #interaction-canvas { max-width: 100%; max-height: 100%; touch-action: none; cursor: pointer; }
        #guide-label { margin-top: 10px; color: #666666; font-size: 13px; font-weight: bold; text-align: center; position: absolute; bottom: 10px; width: 100%; pointer-events: none; }
        #sidebar { width: 300px; background-color: #1a1a1a; display: flex; flex-direction: column; border-left: none; flex-shrink: 0; overflow-y: auto; }
        .sidebar-header { color: white; font-size: 16px; font-weight: bold; padding: 20px 10px 0 10px; background-color: #1a1a1a; }
        .sidebar-sub { color: #666666; font-size: 12px; padding: 5px 10px 10px 10px; }
        #flow-canvas { width: 280px; height: 450px; margin: 0 10px; }
        @media (max-width: 768px) { #main-content { flex-direction: column; } #sidebar { width: 100%; height: 300px; border-top: 1px solid #333; } #flow-canvas { width: 100%; } #controls-bar { flex-wrap: wrap; } .separator { display: none; } .control-group { margin-bottom: 10px; } }
        #login-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #1e1e1e; z-index: 9999; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        #login-box { background-color: #252526; padding: 30px; border: 1px solid #333; border-radius: 5px; text-align: center; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        #login-input { padding: 8px; margin: 10px 0; background-color: #333; border: 1px solid #555; color: white; border-radius: 3px; outline: none; }
        #login-btn { background-color: #007acc; color: white; border: none; padding: 8px 15px; cursor: pointer; border-radius: 3px; font-weight: bold; }
    </style>
</head>
<body>
    <div id="login-overlay"><div id="login-box"><h2 style="margin-top: 0;">Restricted Access</h2><p style="color: #ccc; font-size: 14px;">Enter password
    </p><input type="password" id="login-input" placeholder="Password"><br><button id="login-btn" onclick="checkPassword()">Enter</button><p id="login-error" style="color: #ff6b6b; font-size: 12px; margin-top: 10px; display: none;">Incorrect password</p></div></div>

    <div id="controls-bar">
        <div class="control-group"><span class="group-label">MAIN POWER</span><div class="row-frame"><button onclick="triggerAction('Power')">POWER</button><div id="led-power" class="led-indicator"></div></div></div>
        <div class="separator"></div>
        <div class="control-group"><span class="group-label">INTENSITY</span><div class="row-frame"><button onclick="triggerAction('Boost')">BOOST</button><div id="led-boost" class="led-indicator"></div></div></div>
        <div class="separator"></div>
        <div class="control-group"><span class="group-label">OPERATION</span><div class="row-frame"><button onmousedown="startHold()" onmouseup="stopHold()" ontouchstart="startHold(event)" ontouchend="stopHold(event)" style="width: 140px;">HOLD TO STEAM</button><span id="text-status" class="text-status">READY</span></div></div>
        <div class="separator"></div>
        <div class="control-group"><span class="group-label">VIEW MODE</span><div class="row-frame"><button id="btn-view" onclick="toggleViewMode()">SWITCH TO<br>RENDERS</button></div></div>
    </div>

    <div id="main-content">
        <div id="image-area">
            <canvas id="interaction-canvas"></canvas>
            <div id="guide-label">INTERACTIVE MODE: Click the buttons on the product image (Main or Side view) to operate.</div>
        </div>
        <div id="sidebar">
            <div class="sidebar-header">State Overview</div><div class="sidebar-sub">Logic Decision Tree:</div><canvas id="flow-canvas" width="280" height="450"></canvas>
        </div>
    </div>

    <script>
        function checkPassword() { if (document.getElementById('login-input').value === 'steamer2024') { document.getElementById('login-overlay').style.display = 'none'; startLoop(); } else { document.getElementById('login-error').style.display = 'block'; document.getElementById('login-input').value = ''; } }
        document.getElementById('login-input').addEventListener('keypress', e => { if (e.key === 'Enter') checkPassword(); });

        const originalWidth = 1627;
        const originalHeight = 882;
        const linePoints = { "Power": { x: 365, y: 292 }, "Boost": { x: 366, y: 337 }, "Hold": { x: 777, y: 364, r: 25 }, "Steam": { x: 1385, y: 173 }, "Power_Side": { x: 1051, y: 291 }, "Boost_Side": { x: 1051, y: 341 } };
        const renderPoints = { "Power": { x: 375, y: 347 }, "Boost": { x: 375, y: 382 }, "Hold": { x: 806, y: 419, r: 25 }, "Power_Side": { x: 1100, y: 340 }, "Boost_Side": { x: 1099, y: 386 }, "Hold_Side": { x: 1202, y: 413, r: 25 } };
        const lineRadius = 25; const renderRadius = 18;

        const images = {};
        const imageFiles = { 'line': 'steamer.png', 'alloff': 'Renders/alloff.jpg', 'on': 'Renders/on.jpg', 'onwithsteam': 'Renders/onwithsteam.jpg', 'onwithboost': 'Renders/onwithboost.jpg', 'onboostwithsteam': 'Renders/onboostwithsteam.jpg' };
        for (const [key, src] of Object.entries(imageFiles)) { images[key] = new Image(); images[key].src = src; }

        let state = { powerOn: false, mode: 1, holdActive: false, isHeating: false, heatingStartTime: 0, heatingProgress: 0.0, pulseIntensity: 0.0, viewMode: 'line' };

        function triggerAction(name) {
            if (name.includes('Power')) { state.powerOn = !state.powerOn; if (state.powerOn) state.mode = 1; else { state.mode = 1; state.holdActive = false; cancelHeating(); } }
            else if (name.includes('Boost')) { if (state.powerOn) { if (state.mode === 1) startHeating(); else state.mode = 1; } }
            updateControls();
        }
        function startHeating() { state.isHeating = true; state.heatingStartTime = performance.now() / 1000; state.heatingProgress = 0.0; }
        function cancelHeating() { state.isHeating = false; }
        function finishHeating() { state.isHeating = false; state.mode = 2; }
        function startHold(e) { if (e) e.preventDefault(); if (state.powerOn) { state.holdActive = true; updateControls(); } }
        function stopHold(e) { state.holdActive = false; updateControls(); }
        function toggleViewMode() { state.viewMode = (state.viewMode === 'line') ? 'render' : 'line'; document.getElementById('btn-view').innerHTML = state.viewMode === 'line' ? "SWITCH TO<br>RENDERS" : "SWITCH TO<br>LINES"; }

        function startLoop() { requestAnimationFrame(loop); }
        function loop(timestamp) {
            const now = timestamp / 1000;
            if (state.isHeating) {
                if (!state.powerOn || state.holdActive) cancelHeating();
                else {
                    const elapsed = now - state.heatingStartTime;
                    state.heatingProgress = Math.min(1.0, elapsed / 1.0);
                    if (state.heatingProgress >= 1.0) finishHeating();
                    const pulsePhase = elapsed * (Math.PI * 2);
                    state.pulseIntensity = 0.2 + (((Math.sin(pulsePhase) + 1) / 2) * 0.8);
                }
            } else state.pulseIntensity = 0.0;
            drawMain(); drawFlowchart(); requestAnimationFrame(loop);
        }

        const mainCanvas = document.getElementById('interaction-canvas');
        const mainCtx = mainCanvas.getContext('2d');
        const bufferCanvas = document.createElement('canvas'); // For Tinting
        const bufferCtx = bufferCanvas.getContext('2d');

        function resizeMainCanvas() {
            const container = document.getElementById('image-area');
            const cw = container.clientWidth; const ch = container.clientHeight;
            const ratio = originalWidth / originalHeight;
            let newW = cw; let newH = cw / ratio;
            if (newH > ch) { newH = ch; newW = ch * ratio; }
            mainCanvas.width = newW; mainCanvas.height = newH;
            bufferCanvas.width = newW; bufferCanvas.height = newH;
            mainCtx.imageSmoothingEnabled = true; mainCtx.imageSmoothingQuality = 'high';
            bufferCtx.imageSmoothingEnabled = true; bufferCtx.imageSmoothingQuality = 'high';
        }
        window.addEventListener('resize', resizeMainCanvas); resizeMainCanvas();

        function drawMain() {
            mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
            let bgImage = images.line;
            let renderTag = 'alloff';
            if (state.viewMode === 'render') {
                if (state.powerOn) {
                   if (state.mode === 2 || state.isHeating) {
                        if (state.isHeating) renderTag = (state.pulseIntensity > 0.6) ? 'onwithboost' : 'on';
                        else renderTag = state.holdActive ? 'onboostwithsteam' : 'onwithboost'; 
                   } else renderTag = state.holdActive ? 'onwithsteam' : 'on';
                }
                bgImage = images[renderTag] || images.alloff;
            }
            if (!bgImage) return;

            let source = bgImage;
            // Tint: Use Invert Filter (Works for both Transparent and White-Background images)
            if (state.viewMode === 'line' && bgImage === images.line) {
                mainCtx.save();
                mainCtx.filter = 'invert(1)';
                mainCtx.drawImage(source, 0, 0, mainCanvas.width, mainCanvas.height);
                mainCtx.restore();
            } else {
                mainCtx.globalCompositeOperation = 'source-over';
                mainCtx.drawImage(source, 0, 0, mainCanvas.width, mainCanvas.height);
            }

            const scale = mainCanvas.width / originalWidth;

            if (state.viewMode === 'line' && state.powerOn) {
                mainCtx.globalCompositeOperation = 'screen';
                drawGlow(mainCtx, linePoints.Power.x, linePoints.Power.y, scale, 1.0);
                drawGlow(mainCtx, linePoints.Power_Side.x, linePoints.Power_Side.y, scale, 1.0);
                if (state.mode === 2 || state.isHeating) {
                    let i = state.isHeating ? state.pulseIntensity : 1.0;
                    drawGlow(mainCtx, linePoints.Boost.x, linePoints.Boost.y, scale, i);
                    drawGlow(mainCtx, linePoints.Boost_Side.x, linePoints.Boost_Side.y, scale, i);
                }
                if (state.holdActive) {
                     const isBoost = (state.mode === 2);
                     drawSteamCloud(mainCtx, linePoints.Steam.x * scale, linePoints.Steam.y * scale, "white", isBoost, scale);
                }
                mainCtx.globalCompositeOperation = 'source-over';
            }
            if (state.isHeating && !state.holdActive) drawHeatingOverlay(mainCtx, scale);
        }

        function drawGlow(ctx, x, y, scale, intensity) {
            const r = lineRadius * scale * 1.6; const gx = x * scale; const gy = y * scale;
            const grad = ctx.createRadialGradient(gx, gy, 0, gx, gy, r);
            grad.addColorStop(0, `rgba(255, 255, 255, ${intensity})`); grad.addColorStop(1, `rgba(255, 255, 255, 0)`);
            ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(gx, gy, r, 0, Math.PI * 2); ctx.fill();
        }
        
        function drawSteamCloud(ctx, x, y, color, isBoost, scaleBase) { 
            ctx.save();
            // Move up slightly to compensate for rotation
            ctx.translate(x, y - (25 * scaleBase));
            ctx.rotate(-30 * Math.PI / 180); // Rotate -30 degrees (Up)
            
            const boostScale = isBoost ? 1.4 : 1.0;
            const finalScale = scaleBase * boostScale;
            // Soft Blur Filter
            ctx.filter = `blur(${8 * scaleBase}px)`; 
            // Body (Centered at 0,0 after translate)
            ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
            ctx.beginPath(); ctx.ellipse(0, 0, 60 * finalScale, 30 * finalScale, 0, 0, Math.PI * 2); ctx.fill();
            // Core Line
            const width = (isBoost ? 180 : 120) * scaleBase;
            ctx.lineWidth = (isBoost ? 10 : 6) * scaleBase; ctx.strokeStyle = "rgba(255, 255, 255, 0.6)"; ctx.lineCap = 'round';
            ctx.beginPath(); ctx.moveTo(-width/2, 0); ctx.lineTo(width/2, 0); ctx.stroke();
            ctx.restore();
        }

        function drawHeatingOverlay(ctx, scale) {
             const cx = ctx.canvas.width / 2; const yTop = 40; const w = 300; const h = 100;
             ctx.fillStyle = "#2b2b2b"; ctx.strokeStyle = "#ffffff"; ctx.lineWidth = 2;
             ctx.fillRect(cx - w/2, yTop, w, h); ctx.strokeRect(cx - w/2, yTop, w, h);
             ctx.fillStyle = "#ffffff"; ctx.font = "bold 16px Segoe UI"; ctx.textAlign = "center";
             ctx.fillText("HEATING UP...", cx, yTop + 35);
             const barW = 250; const barH = 12; const bx = cx - barW/2; const by = yTop + 55;
             ctx.fillStyle = "#444444"; ctx.fillRect(bx, by, barW, barH);
             const fillW = barW * state.heatingProgress; ctx.fillStyle = "#ffffff"; ctx.fillRect(bx, by, fillW, barH);
             ctx.fillStyle = "#aaaaaa"; ctx.font = "12px Segoe UI";
             const remaining = Math.max(0, 5.0 * (1.0 - state.heatingProgress));
             ctx.fillText(remaining.toFixed(1) + "s", cx, by + 25);
        }

        function handleInput(x, y) {
            const scale = mainCanvas.width / originalWidth; const rx = x / scale; const ry = y / scale;
            const points = (state.viewMode === 'render') ? renderPoints : linePoints;
            const radius = (state.viewMode === 'render') ? renderRadius : lineRadius;
            for (const [name, p] of Object.entries(points)) {
                let r = p.r || radius; 
                const dist = Math.sqrt((rx - p.x)**2 + (ry - p.y)**2);
                if (dist <= r * 1.5) { if (name.includes('Hold')) startHold(); else triggerAction(name); return; }
            }
        }
        mainCanvas.addEventListener('mousedown', e => { const rect = mainCanvas.getBoundingClientRect(); handleInput(e.clientX - rect.left, e.clientY - rect.top); });
        window.addEventListener('mouseup', () => { if(state.holdActive) stopHold(); });
        mainCanvas.addEventListener('touchstart', e => { const rect = mainCanvas.getBoundingClientRect(); const t = e.touches[0]; handleInput(t.clientX - rect.left, t.clientY - rect.top); }, {passive:true});
        window.addEventListener('touchend', () => { if(state.holdActive) stopHold(); });

        const flowCanvas = document.getElementById('flow-canvas');
        const flowCtx = flowCanvas.getContext('2d');
        
        function drawFlowchart() {
             const w = flowCanvas.width; const h = flowCanvas.height; 
             flowCtx.clearRect(0,0,w,h); 
             const cx = w/2;
             const y1 = 40; const y2 = 130; const y3 = 250;
             const xNorm = 60; const xHeat = 140; const xBoost = 220;
             
             // Nodes
             renderNode(cx, y1, "OFF", 'off', 80, 30);
             renderNode(xNorm, y2, "ON\n(Normal)", 'normal', 80, 40);
             renderNode(xHeat, y2, "Heating\n(wait)", 'heating', 60, 30);
             renderNode(xBoost, y2, "ON\n(Boost)", 'boost', 80, 40);
             renderNode(xNorm, y3, "STEAM\n(Normal)", 'steam_norm', 80, 40);
             renderNode(xBoost, y3, "STEAM\n(Boost)", 'steam_boost', 80, 40);
             
             flowCtx.strokeStyle = "#444444"; flowCtx.fillStyle = "#888888"; 
             flowCtx.font = "italic 10px Segoe UI"; flowCtx.textAlign = "center";

             // Connections
             drawLink(cx, y1+15, xNorm, y2-20); flowCtx.fillText("Power", (cx+xNorm)/2 + 10, (y1+y2)/2);
             drawLink(xNorm+40, y2, xHeat-30, y2);
             drawLink(xHeat+30, y2, xBoost-40, y2);
             
             // Return Loop (Boost -> Norm)
             flowCtx.beginPath(); flowCtx.moveTo(xBoost, y2+20); flowCtx.lineTo(xBoost, y2+35);
             flowCtx.lineTo(xNorm, y2+35); flowCtx.lineTo(xNorm, y2+20); flowCtx.stroke();
             flowCtx.fillText("Boost Btn", xHeat, y2-25);

             drawLink(xNorm, y2+20, xNorm, y3-20); flowCtx.fillText("Hold", xNorm-15, (y2+y3)/2);
             drawLink(xBoost, y2+20, xBoost, y3-20); flowCtx.fillText("Hold", xBoost-15, (y2+y3)/2);
        }

        function drawLink(x1, y1, x2, y2) { flowCtx.beginPath(); flowCtx.moveTo(x1, y1); flowCtx.lineTo(x2, y2); flowCtx.stroke(); }
        
        function renderNode(x, y, txt, tag, w, h) {
            let active = false;
            let fill = '#333'; let stroke = '#555'; let text = '#888';
            
            if (!state.powerOn) { 
                if(tag === 'off') active=true; 
            } else {
                if (state.isHeating) { if(tag === 'heating') active = true; }
                else {
                    if (state.mode === 1) {
                         if (state.holdActive && tag === 'steam_norm') active = true; 
                         else if (!state.holdActive && tag === 'normal') active = true; 
                    } else {
                         if (state.holdActive && tag === 'steam_boost') active = true; 
                         else if (!state.holdActive && tag === 'boost') active = true; 
                    }
                }
            }

            if (active) {
                stroke = '#fff'; text = '#fff';
                if (tag === 'off') fill = '#555';
                else if (tag === 'normal') fill = '#006600';
                else if (tag === 'boost' || tag === 'heating') fill = '#885500';
                else if (tag.includes('steam')) fill = '#006666';
            }

            flowCtx.fillStyle = fill; flowCtx.strokeStyle = stroke; flowCtx.lineWidth = active ? 2 : 1;
            flowCtx.beginPath(); flowCtx.rect(x - w/2, y - h/2, w, h); flowCtx.fill(); flowCtx.stroke();
            
            flowCtx.fillStyle = text; flowCtx.font = active ? "bold 10px Segoe UI" : "10px Segoe UI"; flowCtx.textAlign = "center";
            const lines = txt.split('\n');
            lines.forEach((line, i) => flowCtx.fillText(line, x, y - ((lines.length-1)*5) + (i*10) + 4));
        }

        const ledPower = document.getElementById('led-power'); const ledBoost = document.getElementById('led-boost'); const textStatus = document.getElementById('text-status');
        function updateControls() {
            ledPower.style.backgroundColor = state.powerOn ? '#ffffff' : '#3a3a3a';
            if (state.isHeating) { const v = Math.floor(state.pulseIntensity * 255); const hex = v.toString(16).padStart(2,'0'); ledBoost.style.backgroundColor = `#${hex}${hex}${hex}`; } 
            else { const boostActive = state.powerOn && (state.mode === 2); ledBoost.style.backgroundColor = boostActive ? '#ffffff' : '#3a3a3a'; }
            if (state.powerOn) { textStatus.textContent = state.holdActive ? "STEAMING" : "READY"; textStatus.style.color = state.holdActive ? "#ffffff" : "#00ff00"; } 
            else { textStatus.textContent = "READY"; textStatus.style.color = "#555555"; }
        }
    </script>
</body>
</html>